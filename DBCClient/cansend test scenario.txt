cansend test scenario
run server
run client
candump -tz vcan0

cansend vcan0 123#deadbeef 1000ms (optional: priority #)
cansend vcan0 456#cabcadfe 1500ms 

CANSEND#0x123#DEADBEEF#1000#INTERFACE
CANSEND#123#00000000#1000#vcan0

To verify your vcan0 interface exists, run:
ip link show vcan0
ls -la /sys/class/net/vcan0/
cat /sys/class/net/vcan0/type  # Should show 280

test server to see if it cleans up when it's killed.
make it so that there can be a viewer attached to the server to show output. maybe a candump viewer:
maybe make a graphical map program which shows what's being sent on the bus, with pictures of devices. depending on dbc files or maybe responses, some of the devices will light up. can signify received and sent with different colors

/* priority of todos: 1 high, 2 medium, 3 low

TODOS:
1 Add "set log level" instructions in frontend client tab
1 add timeout in server for client which gets terminated or broken connection

2 Old one-shot tasks might build up in memory, but it might not matter (they are held to show status to FE/GUI)
2 handle cansend errors even more/better
2 add event triggers for sending messages based on can bus activity (like candump -c) and started/stopped tasks
2 triggers for timers (run until x, run at x time); run number of times
2 offload logging to its own thread. but crashes may leave buffer unflushed/unwritten


3 if checking for dead task (LIST_TASKS/UPDATE), return something useful
3 if trying to pause/resume/kill a non-existent task, return something useful
3 add feature to use dns (already implemented?)

POLISH:
make scheduling timer more accurate
maybe add candump-like features to send to ui
add resource monitoring to send to ui
add client feature for server log viewing

*/


Solution â€” step-by-step

Remove the job-level env mapping that references secrets (this triggers the linter error).
For each step that needs secret values, map secrets into step-level env (allowed) and avoid using secrets in workflow 'if' expressions.
Replace step-level 'if' checks with shell-time guards inside the run scripts so the steps skip gracefully when secrets are not provided.
Keep the release body using a step-level env mapping for GPG_KEY_ID so the body can reference it via ${{ env.GPG_KEY_ID }}.