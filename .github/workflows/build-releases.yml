name: Build Releases

on:
  push:
    branches: [ main, main-deployment ]
    tags:
      - 'v*'  # Trigger on version tags like v1.0.0, v1.0.1, etc.
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write  # Required to create releases and upload assets
  packages: write  # Required for Docker registry (ghcr.io)
    inputs:
      build_flatpak:
        description: "Build Flatpak job"
        type: boolean
        default: false
      build_windows:
        description: "Build Windows job"
        type: boolean
        default: false
      build_docker:
        description: "Build Docker job"
        type: boolean
        default: false
      sign_flatpak:
        description: "Sign Flatpak bundle (requires GPG secrets)"
        type: boolean
        default: false
      sign_windows:
        description: "Sign Windows artifacts (requires cert secrets)"
        type: boolean
        default: false
      publish_release:
        description: "Create/Update a GitHub Release (manual runs)"
        type: boolean
        default: false
      release_tag:
        description: "Tag name for manual Release (e.g., v1.0.0)"
        type: string
        default: ""
      release_name:
        description: "Release title (optional)"
        type: string
        default: ""
      release_draft:
        description: "Create as draft (manual Release)"
        type: boolean
        default: true
      release_notes:
        description: "Release notes (markdown) for manual publish"
        type: string
        default: ""

jobs:
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      flatpak: ${{ steps.filter.outputs.flatpak }}
    steps:
      - uses: actions/checkout@v4
      - id: filter
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            flatpak:
              - 'com.qtdevs.DBCParser.yml'
              - 'build-flatpak.sh'
              - 'deploy-assets/**'
              - 'DBCFileViewerContent/**'
              - 'Main.qml'
  build-flatpak:
    # Run Flatpak build only when:
    #  - this is a tag (release), OR
    #  - a manual dispatch explicitly enables it, OR
    #  - relevant files changed (from paths filter).
    if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.build_flatpak) || (github.event_name != 'workflow_dispatch' && needs.changes.outputs.flatpak == 'true') }}
    needs: [changes]
    name: Build Flatpak
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y flatpak flatpak-builder ccache ninja-build git
          
      - name: Add Flathub remote
        run: |
          flatpak remote-add --if-not-exists --user flathub https://flathub.org/repo/flathub.flatpakrepo
          
      - name: Install KDE SDK
        run: |
          flatpak install -y --user flathub org.kde.Platform//6.8 org.kde.Sdk//6.8

      # Cache ccache directory to speed up C++ compilation
      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ~/.cache/ccache
          key: ccache-flatpak-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            ccache-flatpak-${{ runner.os }}-

      # Cache flatpak-builder downloads and build artifacts
      - name: Cache flatpak-builder
        uses: actions/cache@v4
        with:
          path: |
            .flatpak-builder
            flatpak-build
            flatpak-repo
          key: flatpak-builder-${{ runner.os }}-${{ hashFiles('com.qtdevs.DBCParser.yml') }}-${{ github.sha }}
          restore-keys: |
            flatpak-builder-${{ runner.os }}-${{ hashFiles('com.qtdevs.DBCParser.yml') }}-
            flatpak-builder-${{ runner.os }}-

      # Configure ccache for faster rebuilds
      - name: Configure ccache
        run: |
          ccache --set-config=max_size=2G
          ccache --set-config=compression=true
          ccache --zero-stats

      # Set parallel build flags for ninja
      - name: Set build parallelism
        run: |
          echo "NINJAFLAGS=-j$(nproc)" >> $GITHUB_ENV
          echo "Building with $(nproc) parallel jobs"

      # Run the flatpak build script
      - name: Build Flatpak
        run: |
          chmod +x ./build-flatpak.sh
          # Run non-interactively (skip install prompt)
          echo "n" | ./build-flatpak.sh

      # Show ccache statistics
      - name: Show ccache stats
        run: ccache --show-stats

      # Sign Flatpak with GPG (if GPG key is available)
      - name: Sign Flatpak bundle
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.sign_flatpak }}
        run: |
          # Import GPG key from secret
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          
          # Sign the OSTree repo commits
          flatpak build-sign --gpg-sign=${{ secrets.GPG_KEY_ID }} flatpak-repo
          
          # Rebuild bundle with signed commits
          flatpak build-bundle flatpak-repo flatpak/dbc-parser.flatpak com.qtdevs.DBCParser
          
          echo "✓ Flatpak bundle signed with GPG key ${{ secrets.GPG_KEY_ID }}"

      # Upload the flatpak bundle as an artifact
      - name: Upload Flatpak bundle
        uses: actions/upload-artifact@v4
        with:
          name: dbc-parser-flatpak
          path: flatpak/dbc-parser.flatpak
          compression-level: 0
          if-no-files-found: error

      # Optional: Also upload to GitHub Release if this is a tag
      - name: Upload to Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: flatpak/dbc-parser.flatpak
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Manual publish (no tag): attach Flatpak to provided release tag
      - name: Publish Flatpak to Release (manual)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.publish_release && inputs.release_tag != '' }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ inputs.release_tag }}
          # name/draft/body may be set by Windows job; omit here to just append assets
          files: |
            flatpak/dbc-parser.flatpak
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-windows:
    name: Build Windows
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.8.2'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_mingw'
          tools: 'tools_mingw1310'
          cache: true

      - name: Set Qt environment variables
        run: |
          # Try to detect Qt prefix using qmake if available (most reliable)
          $qtPrefix = ""
          $qmakePath = (Get-Command qmake -ErrorAction SilentlyContinue).Path
          if ($qmakePath) {
            Write-Host "qmake detected at: $qmakePath"
            try { $qtPrefix = & qmake -query QT_INSTALL_PREFIX } catch {}
          }

          if (-not $qtPrefix -and $env:Qt6_DIR) {
            $qtPrefix = $env:Qt6_DIR
          }

          if (-not $qtPrefix) {
            # Fallback: search common install-qt-action locations
            $candidates = @(
              "$env:RUNNER_TEMP\Qt\6.*\mingw_64",
              "$env:USERPROFILE\Qt\6.*\mingw_64",
              "C:\\Qt\\6.*\\mingw_64"
            )
            foreach ($pattern in $candidates) {
              $found = Get-ChildItem -Path $pattern -Directory -ErrorAction SilentlyContinue | Sort-Object FullName -Descending | Select-Object -First 1
              if ($found) { $qtPrefix = $found.FullName; break }
            }
          }

          if ($qtPrefix) {
            Write-Host "Qt prefix detected: $qtPrefix"
            echo "Qt6_DIR=$qtPrefix" >> $env:GITHUB_ENV
            echo "CMAKE_PREFIX_PATH=$qtPrefix" >> $env:GITHUB_ENV
          } else {
            Write-Warning "Could not auto-detect Qt prefix; proceeding without explicit CMAKE_PREFIX_PATH"
          }
        shell: pwsh

      - name: Install Ninja
        run: choco install ninja -y

      - name: List files (debug)
        run: |
          Write-Host "Current directory: $(Get-Location)"
          Write-Host "Files in root:"
          Get-ChildItem -Filter "*.ps1" | Select-Object Name
          Write-Host "`nChecking if build-windows.ps1 exists:"
          Test-Path "build-windows.ps1"
          Write-Host "`nQt6_DIR: $env:Qt6_DIR"
          Write-Host "CMAKE_PREFIX_PATH: $env:CMAKE_PREFIX_PATH"
          Write-Host "qmake path: $((Get-Command qmake -ErrorAction SilentlyContinue).Path)"
        shell: pwsh

      - name: Build Windows executable
        run: |
          pwsh -ExecutionPolicy Bypass -File "${{ github.workspace }}/build-windows.ps1"
        shell: pwsh

      - name: Deploy Windows app (windeployqt)
        run: |
          # Pass detected Qt directory if available
          $qtDir = $env:Qt6_DIR
          if ([string]::IsNullOrEmpty($qtDir)) { $qtDir = "$env:USERPROFILE\Qt\6.8.2\mingw_64" }
          pwsh -ExecutionPolicy Bypass -File "${{ github.workspace }}/deploy-windows.ps1" -BuildDir .\build -QtDir "$qtDir" -OutputDir .\deploy\windows
        shell: pwsh

      - name: Verify deployment
        if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.publish_release) }}
        run: |
          Write-Host "Checking deploy directory contents:"
          if (Test-Path "deploy\windows") {
            Get-ChildItem -Path "deploy\windows" -Recurse | Select-Object FullName
          } else {
            Write-Warning "deploy\windows directory not found!"
          }
        shell: pwsh

      - name: Install Inno Setup
        if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.publish_release) }}
        run: choco install innosetup -y

      - name: Build Windows installer
        if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.publish_release) }}
        run: |
          pwsh -ExecutionPolicy Bypass -File "${{ github.workspace }}/build-installer.ps1"
        shell: pwsh
      
      - name: Verify installer output
        if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.publish_release) }}
        run: |
          Write-Host "Checking installer_output directory:"
          if (Test-Path "installer_output") {
            Get-ChildItem -Path "installer_output" -Recurse | Select-Object FullName
          } else {
            Write-Warning "installer_output directory not found!"
          }
        shell: pwsh

      # Sign Windows executable with Authenticode (if certificate is available)
      - name: Sign Windows executable
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.sign_windows }}
        env:
          WINDOWS_CERT_BASE64: ${{ secrets.WINDOWS_CERT_BASE64 }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
        run: |
          # Decode certificate from base64
          $certBytes = [System.Convert]::FromBase64String($env:WINDOWS_CERT_BASE64)
          $certPath = "$env:TEMP\cert.pfx"
          [System.IO.File]::WriteAllBytes($certPath, $certBytes)
          
          # Sign the executable
          $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
          if (-not (Test-Path $signtool)) {
            # Try to find signtool in common locations
            $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "signtool.exe" | 
                        Where-Object { $_.Directory.Name -eq "x64" } | 
                        Select-Object -First 1 -ExpandProperty FullName
          }
          
          if (Test-Path $signtool) {
            & $signtool sign /f $certPath /p $env:WINDOWS_CERT_PASSWORD `
              /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 `
              build-release\appDBC_Parser.exe
            
            # Sign installer if it exists
            if (Test-Path "installer\DBCParser-Setup.exe") {
              & $signtool sign /f $certPath /p $env:WINDOWS_CERT_PASSWORD `
                /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 `
                installer\DBCParser-Setup.exe
            }
            
            Write-Host "✓ Windows executables signed with Authenticode"
          } else {
            Write-Warning "SignTool not found, skipping signing"
          }
          
          # Clean up certificate
          Remove-Item $certPath -Force
        shell: pwsh

      - name: Upload Windows artifacts
        if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.publish_release) }}
        uses: actions/upload-artifact@v4
        with:
          name: dbc-parser-windows
          path: |
            installer_output/DBC_Parser_Setup_*.exe
          compression-level: 0
          if-no-files-found: error

      # Optional: Upload to GitHub Release if this is a tag
      - name: Upload to Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            installer_output/DBC_Parser_Setup_*.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Manual publish (no tag): create/update a Release with provided tag
      - name: Publish Release (manual)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.publish_release && inputs.release_tag != '' }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ inputs.release_tag }}
          name: ${{ inputs.release_name != '' && inputs.release_name || format('DBC Parser {0}', inputs.release_tag) }}
          draft: ${{ inputs.release_draft }}
          body: ${{ inputs.release_notes }}
          files: |
            installer_output/DBC_Parser_Setup_*.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-docker:
    # Run Docker build only when:
    #  - this is a tag (release), OR
    #  - a manual dispatch explicitly enables it
    if: ${{ startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.build_docker) }}
    name: Build Docker Image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: dbc-parser:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Optional: Push to registry if this is a tag
      - name: Login to GitHub Container Registry
        if: startsWith(github.ref, 'refs/tags/')
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push to registry
        if: startsWith(github.ref, 'refs/tags/')
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/dbc-parser:latest
            ghcr.io/${{ github.repository_owner }}/dbc-parser:${{ github.ref_name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
